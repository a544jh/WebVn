<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>AP Canvas</title>
</head>
<style>
    body {
        touch-action: manipulation;
    }
</style>
<body>
    <canvas id="canvas" width="2000" height="400"></canvas>
    <div id="debug"></div>
    <canvas id="work_canvas" width="2000" height="400"></canvas>
</body>
<script>
    let canvasWidth = 2000
    let canvasHeight = 400

    let canvas = document.getElementById('canvas')
    let ctx = canvas.getContext('2d')

    let workCanvas = document.getElementById('work_canvas')
    let workCtx = workCanvas.getContext('2d')

    let step = 0

    let fill = .5
    let fillSpeed = 0
    let fillAcceleration = .005 // per click
    let fillDeceleration = .001 // per frame
    let minFillSpeed = -.0001
    let maxFillSpeed = .0001
    let ripples = []
    let rippleSpeed = .015

    document.addEventListener('click', () => {
        ripples.unshift(0)
        if (fillSpeed < maxFillSpeed) fillSpeed += fillAcceleration
    })

    function animate() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight)
        ctx.save()

        workCtx.clearRect(0, 0, canvasWidth, canvasHeight)
        workCtx.save()

        //let scaleFactor = 8 * Math.sin(step * .01) + 8
        let scaleFactor = 4
        ctx.scale(scaleFactor, scaleFactor)
        workCtx.scale(scaleFactor, scaleFactor)

        let barLength = 370
        let barHeight = 10
        let barX = 25
        let barY = 5

        //border
        ctx.fillStyle = 'black'
        ctx.fillRect(0, 0, 400, 20)
        ctx.strokeStyle = 'white'
        ctx.lineWidth = 2
        ctx.strokeRect(barX - 1, barY - 1, barLength + 2, barHeight + 2)


        let colorStops = []

        let gradient = ctx.createLinearGradient(barX, 0, barX + barLength, 0)

        colorStops.push([0, [0,255,0,1]])

        //add ripple(s)

        for (ripple of ripples) {
            addRipple(colorStops, ripple,.05,.01,[0,255,0,1], [255,255,255,1])
        }

        //glow
        addRipple(colorStops, fill,.01,.01,[255,0,0,1],[255,255,255,1])

        colorStops.push([1,[255,0,0,1]])

        for (let stop of colorStops) {
            gradient.addColorStop(stop[0], `rgba(${stop[1].join(',')})`)
        }

        ctx.fillStyle = gradient
        ctx.save()
        ctx.fillRect(barX, barY, barLength, barHeight)
        ctx.restore()

        let glowWidth = 5

        // TOP GLOW

        workCtx.save()
        workCtx.beginPath()
        workCtx.moveTo(barX-glowWidth,barY-glowWidth)
        workCtx.lineTo(barX+barLength+glowWidth,barY-glowWidth)
        workCtx.lineTo(barX+barLength,barY)
        workCtx.lineTo(barX, barY)
        workCtx.closePath()
        workCtx.strokeStyle = 'black'
        workCtx.clip()
        
        let glowGradient = workCtx.createLinearGradient(0, barY, 0, barY-glowWidth)
        glowGradient.addColorStop(0, 'rgba(0,0,0,1)')
        glowGradient.addColorStop(1, 'rgba(255,255,255,0)')
        workCtx.fillStyle = glowGradient
        workCtx.fillRect(barX-glowWidth, barY-glowWidth, barLength+2*glowWidth, glowWidth + 1)
        workCtx.restore()

        // LEFT GLOW

        workCtx.save()
        workCtx.beginPath()
        workCtx.moveTo(barX-glowWidth,barY-glowWidth)
        workCtx.lineTo(barX, barY)
        workCtx.lineTo(barX, barY+barHeight)
        workCtx.lineTo(barX-glowWidth, barY+barHeight+glowWidth)
        workCtx.closePath()
        workCtx.clip()
        
        glowGradient = workCtx.createLinearGradient(barX, 0, barX-glowWidth, 0)
        glowGradient.addColorStop(0, 'rgba(0,0,0,1)')
        glowGradient.addColorStop(1, 'rgba(255,255,255,0)')
        workCtx.fillStyle = glowGradient
        workCtx.fillRect(barX-glowWidth, barY-glowWidth, glowWidth, barHeight+2*glowWidth)
        workCtx.restore()

        // BOTTOM GLOW

        workCtx.save()
        workCtx.beginPath()
        workCtx.moveTo(barX, barY+barHeight)
        workCtx.lineTo(barX+barLength, barY+barHeight)
        workCtx.lineTo(barX+barLength+glowWidth, barY+barHeight+glowWidth)
        workCtx.lineTo(barX-glowWidth, barY+barHeight+glowWidth)
        workCtx.closePath()
        workCtx.clip()

        glowGradient = workCtx.createLinearGradient(0, barY+barHeight, 0, barY+barHeight+glowWidth)
        glowGradient.addColorStop(0, 'rgba(0,0,0,1)')
        glowGradient.addColorStop(1, 'rgba(255,255,255,0)')
        workCtx.fillStyle = glowGradient
        workCtx.fillRect(barX-glowWidth, barY+barHeight, barLength+2*glowWidth, glowWidth)
        workCtx.restore()

        // RIGHT GLOW

        workCtx.save()
        workCtx.beginPath()
        workCtx.moveTo(barX+barLength, barY)
        workCtx.lineTo(barX+barLength+glowWidth, barY-glowWidth)
        workCtx.lineTo(barX+barLength+glowWidth, barY+barHeight+glowWidth)
        workCtx.lineTo(barX+barLength, barY+barHeight)
        workCtx.closePath()
        workCtx.clip()
        
        glowGradient = workCtx.createLinearGradient(barX+barLength, 0, barX+barLength+glowWidth, 0)
        glowGradient.addColorStop(0, 'rgba(0,0,0,1)')
        glowGradient.addColorStop(1, 'rgba(255,255,255,0)')
        workCtx.fillStyle = glowGradient
        workCtx.fillRect(barX+barLength, barY-glowWidth, glowWidth, barHeight+2*glowWidth)
        workCtx.restore()


        workCtx.fillStyle = gradient
        workCtx.globalCompositeOperation = 'source-in'
        workCtx.fillRect(0, 0, canvasWidth, canvasHeight)

        ctx.save()
        ctx.resetTransform()
        ctx.globalCompositeOperation = 'lighter'
        ctx.drawImage(workCanvas, 0, 0)
        ctx.restore()

        ctx.fillStyle = 'white'
        ctx.font = 'bold 12px monospace'
        ctx.textBaseline = 'top'
        ctx.fillText('AP', 4, 5)

        ctx.restore()
        workCtx.restore()


        let colorStopsStr = colorStops.map(s => s[0].toFixed(5))
        document.getElementById('debug').innerText = `fill ${fill} 
        fillSpeed ${fillSpeed}
        stops ${colorStopsStr}
        ripples ${ripples}`


        fill += fillSpeed
        if (fill < 0) fill = 0
        if (fill >= 1) fill = 1

        if (fillSpeed > minFillSpeed) fillSpeed -= fillDeceleration

        for (let i = 0; i < ripples.length; i++) {
            const element = ripples[i];
            ripples[i] += rippleSpeed
        }
        ripples = ripples.filter(r => r < fill)

        step += 1

        window.requestAnimationFrame(animate)
    }

    window.requestAnimationFrame(animate)


    // given two slopes y=0,1 (x values given), find their intersection y value
    function intersect(top1, bottom1, bottom2, top2) {
        let slope1 = -1 / (bottom1 - top1)
        let slope2 = 1 / (top2 - bottom2)
        // slope1 * top1 + i1 = 1
        // i1 = 1 - slope1 * top1
        let i1 = 1 - slope1 * top1
        let i2 = 1 - slope2 * top2
        // x*slope1 + i1 = x*slope2 + i2
        let x = (i2 - i1) / (slope1 - slope2)
        let y = x * slope1 + i1
        return [x, y]
    }

    function lerp(start, end, t) {
        return start * (1 - t) + end * t
    }

    function arrLerp(arr1, arr2, t) {
        res = []
        for (let i = 0; i < arr1.length; i++) {
            res.push(lerp(arr1[i], arr2[i], t))
        }
        return res
    }

    function parseRGB(input) {
        return input.split("(")[1].split(")")[0].split(",").map(x => +x)
    }

    function lerpRGBA(c1, c2, t) {
        let a1 = parseRGB(c1)
        let a2 = parseRGB(c2)
        let res = arrLerp(a1, a2, t).map(x => x.toFixed(0))
        return `rgba(${res.join(',')})`
    }

    // stops: [distance, [r,g,b,a]]
    function addRipple(stops, point, startDistance, endDistance, bg, fg) {
        let start = point - startDistance
        let end = point + endDistance
        if (start >= 0) {
            let last = stops[stops.length-1]
            let lastTop = stops[stops.length-2]
            if (last !== undefined && start < last[0]) {
                let [x, y] = intersect(lastTop[0], last[0], start, point)
                let c = arrLerp(last[1], lastTop[1], y)
                stops.pop()
                stops.push([x, c])
            } else {
                //let c = last === undefined ? bg : last[1]
                stops.push([start, last[1]])
            }
            stops.push([point, fg])
            if (end <= 1) stops.push([end, bg])
        } else {
            // edge case: ripple start < 0
            let startColor = stops[0][1]

            let slope = 1 / (point - start)
            let y = slope * -start
            let c = arrLerp(startColor, fg, y)
            stops.pop()
            stops.push([0,c])
            stops.push([point,fg])
            if (end <= 1) stops.push([end, bg])
        }
    }
</script>

</html>